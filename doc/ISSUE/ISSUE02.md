# Issue#02: バックエンドサーバー立ち上げ処理を先に行う

## 実装日

2025年12月24日

## 目的

バックエンドサーバーの事前ウォームアップにより、ユーザーが「解析を開始する」ボタンを押した際の待ち時間を短縮し、ユーザー体験を向上させる。

## 背景

### バックエンド環境の制約

- **Renderの無料プラン**を使用
- **15分間アクティブがない場合、サーバーがスリープ状態に入る**
- スリープ状態からの起動には**10〜40秒程度**かかる（Render公式ドキュメントによると最大50秒）
- 現在の実装では「解析を開始する」ボタンを押した時点で初めてAPIリクエストを送信
- ユーザーは**解析処理時間 + サーバー起動時間**を待たされる

### 問題のフロー

```
現在のフロー:
ユーザー操作 → [ファイルアップロード] → [プライバシー確認] → [解析ボタン押下] → ⏰サーバー起動待ち⏰ → 解析処理

問題点:
- ユーザーは解析ボタンを押してから1分以上待たされる可能性
- 待ち時間の内訳が不明瞭（サーバー起動中なのか解析中なのか）
- ユーザー体験が悪い
```

### 解決策のフロー

```
改善後のフロー:
ユーザー操作 → [ファイルアップロード] → 🔥サーバー起動開始🔥 → [プライバシー確認] → [解析ボタン押下] → ✅即座に解析処理✅

改善点:
- ユーザーがプライバシーポリシーを読んでいる間にサーバーが起動
- 解析ボタンを押す頃にはサーバーが起動済み
- 待ち時間が大幅に短縮される
- 待ち時間の内訳を明示（「サーバー起動中...」vs「解析中...」）
```

## 実装内容

### 1. サーバーウォームアップフックの実装

**場所**: `src/hooks/useServerWarmup.ts`

**実装内容**:

```typescript
/**
 * モジュールレベルのフラグ（複数コンポーネント間で共有）
 */
let hasWarmedUp = false; // ウォームアップが完了したかどうか
let isWarmingUp = false; // 現在ウォームアップ中かどうか
let warmupPromise: Promise<void> | null = null; // ウォームアップのPromiseを保存

/**
 * バックエンドサーバーの事前ウォームアップを行うフック
 */
export function useServerWarmup() {
  /**
   * サーバーウォームアップを開始（非同期、即座にreturn）
   * 重複呼び出しを防ぎ、複数コンポーネントから呼ばれても1回だけ実行
   */
  const warmup = useCallback(() => {
    if (hasWarmedUp || isWarmingUp) {
      return; // 既に完了済み or 実行中の場合はスキップ
    }

    isWarmingUp = true;

    // 非同期処理を開始し、Promiseを保存
    warmupPromise = (async () => {
      try {
        await healthCheck();
        hasWarmedUp = true; // ✅ 成功時のみフラグを立てる
      } catch (error) {
        // ❌ 失敗時はフラグをリセットして再試行を許可
        hasWarmedUp = false;
        console.warn('[ServerWarmup] ウォームアップ失敗（解析処理には影響しません）:', error);
      } finally {
        isWarmingUp = false;
        warmupPromise = null;
      }
    })();
  }, []);

  /**
   * ウォームアップの完了を待機
   * 解析開始前に呼び出して、サーバーが起動するまで待つ
   */
  const waitForWarmup = useCallback(async () => {
    if (warmupPromise) {
      await warmupPromise; // 実行中のウォームアップを待つ
    }
  }, []);

  return { warmup, waitForWarmup };
}
```

**設計のポイント**:

1. **モジュールレベルの状態管理**
   - `useRef`ではなく、モジュールレベルの変数を使用
   - 複数コンポーネント間で状態を共有し、重複リクエストを完全に防止

2. **Promise coordination**
   - `warmup()`は即座にreturn（非同期処理をバックグラウンドで開始）
   - `warmupPromise`を保存し、`waitForWarmup()`で完了を待機
   - 解析処理が開始される前に確実にウォームアップを完了させる

3. **エラーハンドリング**
   - 成功時のみ`hasWarmedUp = true`
   - 失敗時はフラグをリセットして再試行を許可
   - ユーザーには通知せず、コンソールに警告のみ出力（silent fail）

### 2. ファイルアップロード時のウォームアップ

**場所**: `src/hooks/useFileUpload.ts`

**修正内容**:

```typescript
export function useFileUpload() {
  const { warmup } = useServerWarmup();

  const validateAndSetFile = useCallback(
    (file: File | null) => {
      // ... バリデーション処理 ...

      setError(null);
      setFileState(file);

      // ✅ ファイルアップロード成功時にサーバーをウォームアップ
      // ユーザーがプライバシーポリシーを読んでいる間にサーバーを起動
      warmup();
    },
    [warmup]
  );

  return { /* ... */ };
}
```

**トリガータイミング**: ファイル選択直後（バリデーション成功後）

**理由**: ユーザーがファイルを選択した時点で解析を意図している可能性が高い

### 3. プライバシーポリシー表示時のウォームアップ

**場所**: `src/app/page.tsx`

**修正内容**:

```typescript
export default function Home() {
  const { warmup } = useServerWarmup();

  const handleOpenPolicy = () => {
    setIsModalOpen(true);
    
    // ✅ プライバシーポリシー表示時にサーバーをウォームアップ
    // ユーザーがポリシーを読んでいる間にサーバーを起動
    warmup();
  };

  return (/* ... */);
}
```

**トリガータイミング**: プライバシーポリシーモーダルを開いた時

**理由**: ユーザーがポリシーを読んでいる間（約10〜30秒）にサーバーを起動しておく

### 4. 解析処理でのウォームアップ完了待機

**場所**: `src/hooks/useAnalyze.ts`

**修正内容**:

```typescript
export function useAnalyze() {
  const { waitForWarmup } = useServerWarmup();
  const [isWaitingForWarmup, setIsWaitingForWarmup] = useState(false);

  const analyze = useCallback(
    async (params: AnalyzeRequestParams) => {
      setIsLoading(true);
      setError(null);
      setResult(null);

      try {
        // ✅ ウォームアップの完了を待機
        setIsWaitingForWarmup(true);
        await waitForWarmup();
        setIsWaitingForWarmup(false);

        // 解析処理を開始
        const response = await analyzeFile(params);
        setResult(response);
        return response;
      } catch (err) {
        // ... エラーハンドリング ...
      } finally {
        setIsLoading(false);
        setIsWaitingForWarmup(false);
      }
    },
    [waitForWarmup]
  );

  return { analyze, isLoading, isWaitingForWarmup, error, result };
}
```

**重要ポイント**:
- `await waitForWarmup()`で、ウォームアップが完了するまで待機
- ウォームアップが既に完了していれば、即座に次に進む
- `isWaitingForWarmup`ステートで、ウォームアップ待機中かどうかを判別

### 5. 差別化されたローディングメッセージ

**場所**: `src/app/page.tsx`

**修正内容**:

```typescript
export default function Home() {
  const { analyze, isLoading, isWaitingForWarmup, error } = useAnalyze();

  return (
    <>
      {/* ... */}
      
      {isLoading && (
        <Loading
          overlay
          message={isWaitingForWarmup ? 'サーバー起動中...' : '解析中...'}
        />
      )}
    </>
  );
}
```

**ユーザー体験の向上**:
- ウォームアップ待機中: 「サーバー起動中...」と表示
- 実際の解析処理中: 「解析中...」と表示
- ユーザーは何を待っているのか明確に理解できる

## ウォームアップのトリガー条件

| トリガー               | タイミング                       | 実装 | 理由                                                   |
| ---------------------- | -------------------------------- | ---- | ------------------------------------------------------ |
| ファイルアップロード   | ファイル選択直後                 | ✅   | ユーザーが解析を意図している可能性が高い               |
| プライバシーポリシー表示 | モーダルを開いた時               | ✅   | ポリシーを読んでいる間にサーバーを起動しておく         |
| ページ初回ロード       | ページを開いた時                 | ❌   | 不要なリクエストを避けるため                           |
| 同意チェックボックス   | チェックボックスをクリックした時 | ❌   | ファイルアップロードで既に実行済み                     |

## テスト結果

### 単体テスト

**場所**: `tests/unit/hooks/useServerWarmup.test.ts`

**実装したテスト**:

1. ✅ **初回呼び出しでヘルスチェック実行**
   - `warmup()`を初回呼び出し時、`healthCheck()`が実行されること

2. ✅ **2回目以降の呼び出しでスキップ**
   - 成功後、`warmup()`を再度呼び出しても`healthCheck()`が実行されないこと

3. ✅ **エラー時のフラグリセット**
   - ウォームアップ失敗時、フラグがリセットされて再試行が許可されること

4. ✅ **グローバルフラグの共有**
   - 別のフック インスタンスからも同じフラグを共有すること

**結果**: 4/4テスト成功

### 統合テスト

**場所**: `tests/integration/serverWarmup.test.tsx`

**実装したテスト**:

1. ✅ **ファイルアップロード時のウォームアップ**
   - ファイル選択時に`healthCheck()`が呼ばれること

2. ✅ **無効なファイル時はウォームアップしない**
   - バリデーションエラー時はウォームアップが実行されないこと

3. ✅ **エラー時もファイル選択は可能**
   - ウォームアップ失敗時もファイル選択処理は正常に動作すること

**結果**: 3/3テスト成功

### 統合テスト（解析フロー）

**場所**: `tests/integration/analyze-flow.test.tsx`

**修正したテスト**:

1. ✅ **解析中はボタンが無効化される**
   - ウォームアップ待機中もボタンが無効化されること
   - 型エラーを修正（`any` → `AnalysisResponse`）

**結果**: 6/6テスト成功

### 全体テスト結果

```bash
npm test
```

**結果**: ✅ **189/189テスト成功（100%成功率）**

```
Test Suites: 23 passed, 23 total
Tests:       189 passed, 189 total
```

### リント・型チェック

```bash
npm run lint
npx tsc --noEmit
```

**結果**: ✅ エラー・警告なし

### ビルド確認

```bash
npm run build
```

**結果**: ✅ ビルド成功

## 本番環境での動作確認

### 検証シナリオ

1. **コールドスタート（サーバースリープ状態）**
   - バックエンドサーバーを15分以上放置してスリープ状態にする
   - フロントエンドでファイルをアップロード
   - プライバシーポリシーを開いて確認
   - 「解析を開始する」ボタンをクリック

2. **期待される動作**
   - ファイルアップロード時に`healthCheck()`リクエストが送信される
   - サーバーが起動を開始（10〜40秒）
   - ユーザーがプライバシーポリシーを読んでいる間にサーバーが起動完了
   - 解析ボタンを押した時点ではサーバーが既に起動済み
   - 即座に解析処理が開始される

3. **実測結果**
   - ✅ ファイルアップロード直後にサーバー起動開始を確認
   - ✅ プライバシーポリシー確認中（約20秒）にサーバー起動完了
   - ✅ 解析ボタン押下後、待ち時間なしで解析開始
   - ✅ ローディングメッセージが正しく表示される
     - 「サーバー起動中...」→「解析中...」

### ウォームアップの効果

| 項目 | 改善前 | 改善後 | 効果 |
|------|--------|--------|------|
| 解析ボタン押下からの待ち時間 | 10〜40秒 + 解析時間 | 解析時間のみ | **サーバー起動時間が実質ゼロに** |
| ユーザーの体感待ち時間 | 非常に長い | 短い | **大幅に改善** |
| 待ち時間の内訳の明確さ | 不明瞭 | 明確 | **ユーザー体験向上** |

## ファイル変更一覧

### 新規作成（1ファイル）

1. **src/hooks/useServerWarmup.ts**
   - サーバーウォームアップフック
   - モジュールレベルのフラグ管理
   - Promise coordination
   - エラーハンドリング

### 修正（3ファイル）

2. **src/hooks/useFileUpload.ts**
   - ファイルアップロード成功時に`warmup()`を呼び出し

3. **src/app/page.tsx**
   - プライバシーポリシー表示時に`warmup()`を呼び出し
   - `isWaitingForWarmup`に基づいてローディングメッセージを切り替え

4. **src/hooks/useAnalyze.ts**
   - 解析開始前に`await waitForWarmup()`を呼び出し
   - `isWaitingForWarmup`ステートを追加

### テストコード追加（2ファイル）

5. **tests/unit/hooks/useServerWarmup.test.ts**
   - 4つの単体テスト

6. **tests/integration/serverWarmup.test.tsx**
   - 3つの統合テスト

### テストコード修正（1ファイル）

7. **tests/integration/analyze-flow.test.tsx**
   - 型エラーの修正（`any` → `AnalysisResponse`）

### ドキュメント更新（1ファイル）

8. **doc/SPEC.md**
   - Issue#02の全タスクを完了マーク
   - 完了日を記録
   - 実装内容のサマリーを追加

## 技術的な学び

### 1. モジュールレベルの状態管理

**教訓**: 複数コンポーネント間で状態を共有する場合、`useRef`ではなくモジュールレベルの変数を使用する方が適切。

- `useRef`はコンポーネントインスタンスごとに独立した値を持つ
- モジュールレベルの変数は、すべてのコンポーネントで共有される
- 重複リクエストを完全に防止できる

### 2. Promise coordination パターン

**教訓**: 非同期処理を開始するだけの関数と、完了を待つ関数を分けることで、柔軟な制御が可能。

```typescript
// ✅ Good: 開始と待機を分離
warmup();        // すぐにreturn（バックグラウンドで実行）
// ... ユーザーがポリシーを読む時間 ...
await waitForWarmup();  // 必要になったら完了を待つ

// ❌ Bad: 開始と待機が一体
await warmup();  // ここでブロックしてしまう
```

### 3. Silent fail の重要性

**教訓**: ウォームアップはベストエフォートであり、失敗しても本来の処理には影響させない。

- ウォームアップ失敗時もユーザーには通知しない
- コンソールに警告のみ出力
- 従来通り解析ボタン押下時にサーバーが起動する（フォールバック）
- ユーザー体験を損なわない

### 4. ユーザーへの明示的なフィードバック

**教訓**: 待ち時間が長い場合、何を待っているのかを明確に示すことが重要。

- 「サーバー起動中...」vs「解析中...」の区別
- ユーザーは状況を理解でき、安心して待てる
- 体感待ち時間が短くなる

## 影響範囲

### ✅ 改善された点

- **ユーザー体験**: サーバー起動待ち時間が実質ゼロに
- **待ち時間の透明性**: 何を待っているのかが明確
- **信頼性**: エラー時もフォールバックが機能

### ✅ 影響なし

- **既存機能**: すべての既存機能は正常に動作
- **API仕様**: バックエンドAPIに変更なし
- **テスト**: 全テストが通過（189/189）

### ⚠️ 注意事項

- ウォームアップはベストエフォート（失敗しても解析は可能）
- Renderの無料プランの制約は変わらない（15分でスリープ）
- 不要なリクエストを避けるため、ページ初回ロードではウォームアップしない

## 将来的な改善案

### 1. プリエンプティブウォームアップ

- ページを開いた時点でウォームアップを開始（オプション）
- ユーザー設定で有効/無効を切り替え可能

### 2. ウォームアップステータスの表示

- 「サーバーは起動済みです」などの表示
- ユーザーがサーバー状態を確認できる

### 3. リトライロジックの追加

- ウォームアップ失敗時に自動リトライ
- 指数バックオフによる再試行

### 4. サーバー側の改善

- Render有料プランへの移行（スリープなし）
- より高速な起動時間

## 完了条件

- [x] `useServerWarmup`フックが実装されている
- [x] ファイルアップロード時にウォームアップが実行される
- [x] プライバシーポリシー表示時にウォームアップが実行される
- [x] 解析前にウォームアップ完了を待機する
- [x] 差別化されたローディングメッセージが表示される
- [x] 全テストが通過している（189/189）
- [x] リント・型チェックが通過している
- [x] 本番環境で動作確認が完了している
- [x] 仕様書が更新されている
- [x] PRドキュメントが作成されている

## 依存

- なし（既存の `healthCheck()` 関数を利用）

## 次のステップ

- PR#10: アニメーション演出（オプション）
- PR#11: E2Eテスト・統合テスト
- PR#12: 最終調整・リリース準備

## 備考

### Renderの無料プランについて

Renderの無料プランは以下の特性があります：

- **スリープ**: 15分間リクエストがないと自動的にスリープ
- **起動時間**: スリープからの起動に10〜40秒（最大50秒）かかる
- **初回リクエスト**: スリープ中のサーバーへの初回リクエストは起動を待つ必要がある

今回の実装により、ユーザーは実質的にこの起動時間を待つ必要がなくなります。

### 開発時の検証方法

開発環境では以下の方法でウォームアップ動作を確認できます：

1. バックエンドサーバーを停止
2. フロントエンドでファイルをアップロード
3. ブラウザの開発者ツール（Network タブ）を確認
4. `healthCheck()`リクエストが送信されていることを確認
5. バックエンドサーバーを起動
6. 解析ボタンを押して、すぐに解析が開始されることを確認

### クロスプラットフォーム対応

この実装は、あらゆるホスティングサービスで動作します：

- Render（今回のターゲット）
- Heroku（同様のスリープ機能あり）
- AWS Lambda（コールドスタート対策）
- その他のサーバーレス環境

サーバー起動時間が長い環境であればあるほど、この実装の効果が高まります。
